import * as vscode from 'vscode';
import { BaseSafetyValidator } from './BaseSafetyValidator';
import { LanguageConfig } from '../../config/LanguageConfigs';

export class SafetyItemValidator extends BaseSafetyValidator {
    
    constructor() {
        // Create a basic language config for safety item files
        const itemConfig: LanguageConfig = {
            id: 'sylang-safety',
            keywords: ['def', 'hazardanalysis', 'scenario', 'condition', 'strategy', 'principle', 'name', 'description'],
            requiredProperties: ['name', 'description'],
            validPropertyValues: {}
        };
        super(itemConfig);
    }

    protected getDefinitionKeywords(): string[] {
        return ['hazardanalysis', 'scenario', 'condition', 'strategy', 'principle'];
    }

    protected async validateDocumentLevelRules(document: vscode.TextDocument): Promise<void> {
        await this.validateHazardAnalysisStructure(document);
        await this.validateScenarioCompleteness(document);
        await this.validateCrossReferences(document);
    }

    protected async validateLanguageSpecificRules(document: vscode.TextDocument, lineIndex: number, line: string): Promise<void> {
        const trimmedLine = line.trim();

        // Validate scenario definitions
        if (trimmedLine.startsWith('def scenario ')) {
            this.validateScenarioDefinition(document, lineIndex, line);
        }

        // Validate condition definitions
        if (trimmedLine.startsWith('def condition ')) {
            this.validateConditionDefinition(document, lineIndex, line);
        }

        // Validate strategy definitions
        if (trimmedLine.startsWith('def strategy ')) {
            this.validateStrategyDefinition(document, lineIndex, line);
        }

        // Validate principle definitions
        if (trimmedLine.startsWith('def principle ')) {
            this.validatePrincipleDefinition(document, lineIndex, line);
        }

        // Validate references
        this.validateItemReferences(document, lineIndex, line);
    }

    public override async validate(document: vscode.TextDocument): Promise<vscode.Diagnostic[]> {
        this.diagnostics = [];
        const text = document.getText();
        const lines = text.split('\n');

        // Validate file must start with 'def hazardanalysis'
        if (!text.trim().startsWith('def hazardanalysis')) {
            this.addError(0, 'Safety item files (.itm) must start with "def hazardanalysis <identifier>"');
        }

        // Validate required sections for .itm files
        this.validateRequiredSections(document, [
            'itemdef',
            'operationalscenarios',
            'safetyconcept'
        ]);

        // Validate required subsections within itemdef
        this.validateRequiredItemDefSections(document);

        // Validate line-by-line content
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (!line || line.trim().length === 0 || line.trim().startsWith('//')) {
                continue;
            }

            await this.validateLine(document, i, line);
        }

        // Validate overall structure and consistency
        await this.validateOverallStructure(document);

        return this.diagnostics;
    }

    private async validateLine(document: vscode.TextDocument, lineIndex: number, line: string): Promise<void> {
        const trimmedLine = line.trim();

        // Common validations from base class - handled by parent
        await this.validateCrossFileReferences(document, lineIndex, line);
        this.validateASILConsistency(document, lineIndex, line);
        this.validateSafetyNamingConventions(document, lineIndex, line);

        // Specific validations for .itm files
        await this.validateItemDefinitionReferences(document, lineIndex, line);
        this.validateOperationalScenarios(document, lineIndex, line);
        this.validateVehicleStates(document, lineIndex, line);
        this.validateEnvironmentalConditions(document, lineIndex, line);
        this.validateSafetyConcept(document, lineIndex, line);
    }

    private validateRequiredItemDefSections(document: vscode.TextDocument): void {
        const text = document.getText();
        const itemDefRequiredSections = [
            'productline',
            'systemfeatures', 
            'systemfunctions',
            'systemboundaries'
        ];

        for (const section of itemDefRequiredSections) {
            if (!text.includes(section)) {
                const range = new vscode.Range(0, 0, 0, 0);
                const diagnostic = new vscode.Diagnostic(
                    range,
                    `Missing required itemdef section: ${section}`,
                    vscode.DiagnosticSeverity.Error
                );
                diagnostic.code = 'missing-itemdef-section';
                this.diagnostics.push(diagnostic);
            }
        }
    }

    private async validateItemDefinitionReferences(document: vscode.TextDocument, lineIndex: number, line: string): Promise<void> {
        const trimmedLine = line.trim();

        // Validate subsystem references
        if (trimmedLine.startsWith('subsystems') || (line.includes('  ') && trimmedLine.match(/^[A-Z][A-Za-z0-9_]*$/))) {
            // This could be a subsystem reference - validate it exists
            const subsystemMatch = trimmedLine.match(/^([A-Z][A-Za-z0-9_]*)$/);
            if (subsystemMatch) {
                const subsystemName = subsystemMatch[1];
                // Check if subsystem is defined in component files
                const componentFiles = await vscode.workspace.findFiles('**/*.{cmp,sub}', '**/node_modules/**');
                let found = false;
                for (const fileUri of componentFiles) {
                    const doc = await vscode.workspace.openTextDocument(fileUri);
                    if (doc.getText().includes(`subsystem ${subsystemName}`) || 
                        doc.getText().includes(`component ${subsystemName}`)) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    this.addWarning(lineIndex, `Subsystem '${subsystemName}' referenced but not found in component files`);
                }
            }
        }
    }

    private validateOperationalScenarios(document: vscode.TextDocument, lineIndex: number, line: string): void {
        const trimmedLine = line.trim();

        // Validate scenario definitions
        if (trimmedLine.startsWith('def scenario ')) {
            const scenarioMatch = trimmedLine.match(/def\s+scenario\s+([A-Z][A-Za-z0-9_]*)/);
            if (scenarioMatch) {
                const scenarioId = scenarioMatch[1];
                
                // Validate naming convention: SCEN_NNN_Name
                if (!scenarioId.match(/^SCEN_\d{3}_[A-Za-z][A-Za-z0-9_]*$/)) {
                    this.addWarning(lineIndex, `Scenario ID '${scenarioId}' should follow pattern SCEN_NNN_Name (e.g., SCEN_001_NormalDriving)`);
                }
            }
        }

        // Validate scenario properties
        if (trimmedLine.startsWith('vehiclestate ')) {
            const stateRef = trimmedLine.replace('vehiclestate ', '').trim();
            // Should reference a defined vehicle state
            const text = document.getText();
            if (!text.includes(`def vehiclestate ${stateRef}`)) {
                this.addError(lineIndex, `Vehicle state '${stateRef}' referenced but not defined`);
            }
        }

        if (trimmedLine.startsWith('environment ')) {
            const envRef = trimmedLine.replace('environment ', '').trim();
            const validEnvironments = ['ENV_NORMAL', 'ENV_EXTREME_COLD', 'ENV_EXTREME_HEAT', 'ENV_WET', 'ENV_DRY'];
            if (!validEnvironments.includes(envRef)) {
                this.addWarning(lineIndex, `Environment '${envRef}' should be one of: ${validEnvironments.join(', ')}`);
            }
        }
    }

    private validateVehicleStates(document: vscode.TextDocument, lineIndex: number, line: string): void {
        const trimmedLine = line.trim();

        // Validate vehicle state definitions
        if (trimmedLine.startsWith('def vehiclestate ')) {
            const stateMatch = trimmedLine.match(/def\s+vehiclestate\s+([A-Za-z][A-Za-z0-9_]*)/);
            if (stateMatch) {
                const stateName = stateMatch[1];
                
                // Common vehicle states should follow conventions
                const commonStates = ['Parked', 'Driving', 'Standby', 'Emergency', 'Maintenance'];
                if (!commonStates.some(common => stateName.includes(common))) {
                    this.addInfo(lineIndex, `Consider using standard vehicle state names: ${commonStates.join(', ')}`);
                }
            }
        }

        // Validate driver state definitions  
        if (trimmedLine.startsWith('def drivingstate ')) {
            const driverStateMatch = trimmedLine.match(/def\s+drivingstate\s+([A-Za-z][A-Za-z0-9_]*)/);
            if (driverStateMatch) {
                const driverState = driverStateMatch[1];
                const validDriverStates = ['Alert', 'Distracted', 'Impaired', 'Attentive', 'Inattentive'];
                if (!validDriverStates.some(valid => driverState.includes(valid))) {
                    this.addInfo(lineIndex, `Consider using standard driver states: ${validDriverStates.join(', ')}`);
                }
            }
        }
    }

    private validateEnvironmentalConditions(document: vscode.TextDocument, lineIndex: number, line: string): void {
        const trimmedLine = line.trim();

        // Validate condition definitions
        if (trimmedLine.startsWith('condition ')) {
            const conditionMatch = trimmedLine.match(/condition\s+([A-Z][A-Z0-9_]*)/);
            if (conditionMatch) {
                const conditionId = conditionMatch[1];
                
                // Validate naming convention for conditions
                if (!conditionId.match(/^[A-Z]{3,}_[A-Z0-9_]+_\d{3}$/)) {
                    this.addWarning(lineIndex, `Condition ID '${conditionId}' should follow pattern TYPE_NAME_NNN (e.g., TEMP_RANGE_001)`);
                }
            }
        }

        // Validate range specifications
        if (trimmedLine.startsWith('range ')) {
            const rangeValue = trimmedLine.replace('range ', '').trim();
            if (!rangeValue.startsWith('"') || !rangeValue.endsWith('"')) {
                this.addError(lineIndex, 'Range values must be quoted strings');
            }
        }
    }

    private validateSafetyConcept(document: vscode.TextDocument, lineIndex: number, line: string): void {
        const trimmedLine = line.trim();

        // Validate safety strategy definitions
        if (trimmedLine.startsWith('def overallsafetystrategy ')) {
            const strategyMatch = trimmedLine.match(/def\s+overallsafetystrategy\s+([A-Z][A-Z0-9_]*)/);
            if (strategyMatch) {
                const strategyId = strategyMatch[1];
                
                // Validate naming convention
                if (!strategyId.match(/^STRATEGY_\d{3}$/)) {
                    this.addWarning(lineIndex, `Strategy ID '${strategyId}' should follow pattern STRATEGY_NNN (e.g., STRATEGY_001)`);
                }
            }
        }

        // Validate principle definitions
        if (trimmedLine.startsWith('principle ')) {
            const principleMatch = trimmedLine.match(/principle\s+([A-Z][A-Z0-9_]*)/);
            if (principleMatch) {
                const principleId = principleMatch[1];
                
                // Validate naming convention
                if (!principleId.match(/^PRIN_\d{3}$/)) {
                    this.addWarning(lineIndex, `Principle ID '${principleId}' should follow pattern PRIN_NNN (e.g., PRIN_001)`);
                }
            }
        }
    }

    private async validateOverallStructure(document: vscode.TextDocument): Promise<void> {
        const text = document.getText();
        
        // Validate that there's exactly one hazardanalysis definition
        const hazardAnalysisMatches = text.match(/def\s+hazardanalysis/g);
        if (!hazardAnalysisMatches) {
            this.addError(0, 'Missing "def hazardanalysis" definition');
        } else if (hazardAnalysisMatches.length > 1) {
            this.addError(0, 'Multiple "def hazardanalysis" definitions found. Only one is allowed per file.');
        }

        // Validate section order
        const sectionOrder = ['itemdef', 'operationalscenarios', 'safetyconcept'];
        let lastFoundIndex = -1;
        
        for (const section of sectionOrder) {
            const sectionIndex = text.indexOf(section);
            if (sectionIndex !== -1) {
                if (sectionIndex < lastFoundIndex) {
                    this.addWarning(0, `Section '${section}' appears before previous required section. Recommended order: ${sectionOrder.join(' → ')}`);
                }
                lastFoundIndex = sectionIndex;
            }
        }

        // Validate cross-references consistency
        await this.validateCrossReferencesConsistency(document);
    }

    private async validateCrossReferencesConsistency(document: vscode.TextDocument): Promise<void> {
        const text = document.getText();
        
        // Ensure all referenced scenarios in operational scenarios are actually defined
        const scenarioRefs = text.match(/scenario\s+([A-Z][A-Za-z0-9_]*)/g);
        const scenarioDefs = text.match(/def\s+scenario\s+([A-Z][A-Za-z0-9_]*)/g);
        
        if (scenarioRefs && scenarioDefs) {
            const refs = scenarioRefs.map(ref => ref.replace('scenario ', ''));
            const defs = scenarioDefs.map(def => def.replace('def scenario ', ''));
            
            for (const ref of refs) {
                if (!defs.includes(ref)) {
                    this.addError(0, `Scenario '${ref}' is referenced but not defined in this file`);
                }
            }
        }
        
        // Ensure all referenced vehicle states are defined
        const stateRefs = text.match(/vehiclestate\s+([A-Za-z][A-Za-z0-9_]*)/g);
        const stateDefs = text.match(/def\s+vehiclestate\s+([A-Za-z][A-Za-z0-9_]*)/g);
        
        if (stateRefs && stateDefs) {
            const refs = stateRefs.map(ref => ref.replace('vehiclestate ', ''));
            const defs = stateDefs.map(def => def.replace('def vehiclestate ', ''));
            
            for (const ref of refs) {
                if (!defs.includes(ref)) {
                    this.addError(0, `Vehicle state '${ref}' is referenced but not defined in this file`);
                }
            }
        }
    }
} 