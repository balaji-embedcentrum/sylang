import * as vscode from 'vscode';
import { BaseSafetyValidator } from './BaseSafetyValidator';
import { LanguageConfig } from '../../config/LanguageConfigs';

export class RiskValidator extends BaseSafetyValidator {
    
    constructor() {
        // Create a basic language config for risk assessment files
        const riskConfig: LanguageConfig = {
            id: 'sylang-safety',
            keywords: ['def', 'riskassessment', 'hazard', 'severity', 'exposure', 'controllability', 'asil'],
            requiredProperties: ['severity', 'exposure', 'controllability', 'asil'],
            validPropertyValues: {
                severity: ['S1', 'S2', 'S3'],
                exposure: ['E1', 'E2', 'E3', 'E4'],
                controllability: ['C1', 'C2', 'C3'],
                asil: ['A', 'B', 'C', 'D', 'QM']
            }
        };
        super(riskConfig);
    }

    protected getDefinitionKeywords(): string[] {
        return ['riskassessment', 'severity', 'exposure', 'controllability'];
    }

    protected async validateDocumentLevelRules(document: vscode.TextDocument): Promise<void> {
        await this.validateRiskAssessmentStructure(document);
        await this.validateRiskCriteria(document);
        await this.validateHazardRiskAssessments(document);
    }

    protected async validateLanguageSpecificRules(document: vscode.TextDocument, lineIndex: number, line: string): Promise<void> {
        const trimmedLine = line.trim();

        // Validate risk criteria
        if (trimmedLine.includes('severity ') || trimmedLine.includes('exposure ') || trimmedLine.includes('controllability ')) {
            this.validateRiskCriteriaLine(document, lineIndex, line);
        }

        // Validate ASIL determinations
        if (trimmedLine.includes('asil ')) {
            this.validateASILDetermination(document, lineIndex, line);
        }

        // Validate hazard references
        if (trimmedLine.startsWith('hazard ')) {
            this.validateHazardReference(document, lineIndex, line);
        }
    }

    public override async validate(document: vscode.TextDocument): Promise<vscode.Diagnostic[]> {
        this.diagnostics = [];
        const text = document.getText();
        const lines = text.split('\n');

        // Validate file must start with 'def riskassessment'
        if (!text.trim().startsWith('def riskassessment')) {
            this.addError(0, 'Risk assessment files (.rsk) must start with "def riskassessment <identifier>"');
        }

        // Validate required sections for .rsk files
        this.validateRequiredSections(document, [
            'riskcriteria',
            'assessment'
        ]);

        // Validate line-by-line content
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (!line || line.trim().length === 0 || line.trim().startsWith('//')) {
                continue;
            }

            await this.validateLine(document, i, line);
        }

        // Validate overall structure and consistency
        await this.validateOverallStructure(document);

        return this.diagnostics;
    }

    private async validateLine(document: vscode.TextDocument, lineIndex: number, line: string): Promise<void> {
        const trimmedLine = line.trim();

        // Common validations from base class - handled by parent
        await this.validateCrossFileReferences(document, lineIndex, line);
        this.validateASILConsistency(document, lineIndex, line);
        this.validateSafetyNamingConventions(document, lineIndex, line);

        // Specific validations for .rsk files
        this.validateRiskCriteria(document, lineIndex, line);
        this.validateSECAssessment(document, lineIndex, line);
        this.validateASILMatrix(document, lineIndex, line);
        this.validateMethodology(document, lineIndex, line);
        await this.validateHazardReferences(document, lineIndex, line);
    }

    private validateRiskCriteria(document: vscode.TextDocument, lineIndex: number, line: string): void {
        const trimmedLine = line.trim();

        // Validate severity criteria
        if (trimmedLine.startsWith('severity') && !trimmedLine.includes('S1') && !trimmedLine.includes('S2') && !trimmedLine.includes('S3')) {
            // This is the severity section header
            return;
        }

        if (trimmedLine.match(/^S[1-3]\s/)) {
            const severityMatch = trimmedLine.match(/^(S[1-3])\s+"([^"]+)"/);
            if (!severityMatch) {
                this.addError(lineIndex, 'Severity definitions must follow format: S1 "description"');
                return;
            }
            
            const severityLevel = severityMatch[1];
            const description = severityMatch[2];
            
            // Validate severity levels against ISO 26262 definitions
            const expectedDescriptions = {
                'S1': ['light', 'moderate', 'injuries'],
                'S2': ['severe', 'life-threatening', 'injuries'],
                'S3': ['life-threatening', 'fatal', 'injuries']
            };
            
            const expectedKeywords = expectedDescriptions[severityLevel as keyof typeof expectedDescriptions];
            if (!expectedKeywords.some(keyword => description.toLowerCase().includes(keyword))) {
                this.addWarning(lineIndex, `Severity ${severityLevel} description should include terms: ${expectedKeywords.join(', ')}`);
            }
        }

        // Validate exposure criteria
        if (trimmedLine.match(/^E[1-4]\s/)) {
            const exposureMatch = trimmedLine.match(/^(E[1-4])\s+"([^"]+)"/);
            if (!exposureMatch) {
                this.addError(lineIndex, 'Exposure definitions must follow format: E1 "description"');
                return;
            }
            
            const exposureLevel = exposureMatch[1];
            const description = exposureMatch[2];
            
            // Validate exposure levels against ISO 26262 definitions
            const expectedDescriptions = {
                'E1': ['unlikely', 'rare'],
                'E2': ['likely', 'occasional'],
                'E3': ['probable', 'frequent'],
                'E4': ['highly probable', 'very frequent']
            };
            
            const expectedKeywords = expectedDescriptions[exposureLevel as keyof typeof expectedDescriptions];
            if (expectedKeywords && !expectedKeywords.some(keyword => description.toLowerCase().includes(keyword))) {
                this.addWarning(lineIndex, `Exposure ${exposureLevel} description should include terms: ${expectedKeywords.join(', ')}`);
            }
        }

        // Validate controllability criteria
        if (trimmedLine.match(/^C[1-3]\s/)) {
            const controllabilityMatch = trimmedLine.match(/^(C[1-3])\s+"([^"]+)"/);
            if (!controllabilityMatch) {
                this.addError(lineIndex, 'Controllability definitions must follow format: C1 "description"');
                return;
            }
            
            const controllabilityLevel = controllabilityMatch[1];
            const description = controllabilityMatch[2];
            
            // Validate controllability levels against ISO 26262 definitions
            const expectedDescriptions = {
                'C1': ['simply', 'controllable', 'easy'],
                'C2': ['normally', 'controllable', 'average'],
                'C3': ['difficult', 'control', 'challenging']
            };
            
            const expectedKeywords = expectedDescriptions[controllabilityLevel as keyof typeof expectedDescriptions];
            if (!expectedKeywords.some(keyword => description.toLowerCase().includes(keyword))) {
                this.addWarning(lineIndex, `Controllability ${controllabilityLevel} description should include terms: ${expectedKeywords.join(', ')}`);
            }
        }
    }

    private validateSECAssessment(document: vscode.TextDocument, lineIndex: number, line: string): void {
        const trimmedLine = line.trim();

        // Validate individual S×E×C assessments
        if (trimmedLine.startsWith('severity S')) {
            const severityMatch = trimmedLine.match(/severity\s+(S[1-3])/);
            if (!severityMatch) {
                this.addError(lineIndex, 'Invalid severity value. Valid values are: S1, S2, S3');
            }
        }

        if (trimmedLine.startsWith('exposure E')) {
            const exposureMatch = trimmedLine.match(/exposure\s+(E[1-4])/);
            if (!exposureMatch) {
                this.addError(lineIndex, 'Invalid exposure value. Valid values are: E1, E2, E3, E4');
            }
        }

        if (trimmedLine.startsWith('controllability C')) {
            const controllabilityMatch = trimmedLine.match(/controllability\s+(C[1-3])/);
            if (!controllabilityMatch) {
                this.addError(lineIndex, 'Invalid controllability value. Valid values are: C1, C2, C3');
            }
        }

        // Validate rationale is provided
        if (trimmedLine.startsWith('rationale ')) {
            const rationaleValue = trimmedLine.replace('rationale ', '').trim();
            if (!rationaleValue.startsWith('"') || !rationaleValue.endsWith('"')) {
                this.addError(lineIndex, 'Rationale must be a quoted string');
            } else if (rationaleValue.length < 20) {
                this.addWarning(lineIndex, 'Rationale should provide detailed justification for ASIL determination');
            }
        }
    }

    private validateASILMatrix(document: vscode.TextDocument, lineIndex: number, line: string): void {
        const trimmedLine = line.trim();

        // Validate ASIL determination
        if (trimmedLine.startsWith('asil ')) {
            const asilMatch = trimmedLine.match(/asil\s+([A-D]|QM)/);
            if (!asilMatch) {
                this.addError(lineIndex, 'Invalid ASIL level. Valid values are: A, B, C, D, QM');
                return;
            }

            const asilLevel = asilMatch[1];
            
            // Validate ASIL against S×E×C values in the same assessment block
            this.validateASILDetermination(document, lineIndex, asilLevel);
        }
    }

    private validateASILDetermination(document: vscode.TextDocument, lineIndex: number, expectedASIL: string): void {
        const lines = document.getText().split('\n');
        
        // Look for S×E×C values in the same hazard assessment block
        let severity: string | null = null;
        let exposure: string | null = null;
        let controllability: string | null = null;
        
        // Find the current assessment block boundaries
        let blockStart = lineIndex;
        let blockEnd = lineIndex;
        
        // Find block start (hazard line)
        for (let i = lineIndex; i >= 0; i--) {
            if (lines[i].trim().startsWith('hazard ')) {
                blockStart = i;
                break;
            }
        }
        
        // Find block end (next hazard or end of assessment)
        for (let i = lineIndex; i < lines.length; i++) {
            if (lines[i].trim().startsWith('hazard ') && i > lineIndex) {
                blockEnd = i;
                break;
            }
            if (i === lines.length - 1) {
                blockEnd = i;
                break;
            }
        }
        
        // Extract S×E×C values from the block
        for (let i = blockStart; i <= blockEnd; i++) {
            const line = lines[i].trim();
            
            const severityMatch = line.match(/severity\s+(S[1-3])/);
            if (severityMatch) severity = severityMatch[1];
            
            const exposureMatch = line.match(/exposure\s+(E[1-4])/);
            if (exposureMatch) exposure = exposureMatch[1];
            
            const controllabilityMatch = line.match(/controllability\s+(C[1-3])/);
            if (controllabilityMatch) controllability = controllabilityMatch[1];
        }
        
        // Validate S×E×C to ASIL mapping according to ISO 26262
        if (severity && exposure && controllability) {
            const calculatedASIL = this.calculateASILFromSEC(severity, exposure, controllability);
            if (calculatedASIL !== expectedASIL) {
                this.addError(lineIndex, `ASIL level '${expectedASIL}' doesn't match S×E×C determination. Expected: ${calculatedASIL} (S=${severity}, E=${exposure}, C=${controllability})`);
            }
        }
    }

    private calculateASILFromSEC(severity: string, exposure: string, controllability: string): string {
        // ISO 26262 S×E×C to ASIL mapping table
        const asilMatrix: Record<string, Record<string, Record<string, string>>> = {
            'S1': {
                'E1': { 'C1': 'QM', 'C2': 'QM', 'C3': 'QM' },
                'E2': { 'C1': 'QM', 'C2': 'QM', 'C3': 'A' },
                'E3': { 'C1': 'QM', 'C2': 'A', 'C3': 'B' },
                'E4': { 'C1': 'QM', 'C2': 'A', 'C3': 'B' }
            },
            'S2': {
                'E1': { 'C1': 'QM', 'C2': 'QM', 'C3': 'A' },
                'E2': { 'C1': 'QM', 'C2': 'A', 'C3': 'B' },
                'E3': { 'C1': 'A', 'C2': 'B', 'C3': 'C' },
                'E4': { 'C1': 'A', 'C2': 'B', 'C3': 'C' }
            },
            'S3': {
                'E1': { 'C1': 'QM', 'C2': 'A', 'C3': 'B' },
                'E2': { 'C1': 'A', 'C2': 'B', 'C3': 'C' },
                'E3': { 'C1': 'B', 'C2': 'C', 'C3': 'D' },
                'E4': { 'C1': 'B', 'C2': 'C', 'C3': 'D' }
            }
        };
        
        return asilMatrix[severity]?.[exposure]?.[controllability] || 'Unknown';
    }

    private validateMethodology(document: vscode.TextDocument, lineIndex: number, line: string): void {
        const trimmedLine = line.trim();

        // Validate methodology specification
        if (trimmedLine.startsWith('methodology ')) {
            const methodologyMatch = trimmedLine.match(/methodology\s+"([^"]+)"/);
            if (methodologyMatch) {
                const methodology = methodologyMatch[1];
                
                // Should mention S×E×C and ISO 26262
                if (!methodology.includes('S×E×C') && !methodology.includes('SxExC')) {
                    this.addWarning(lineIndex, 'Risk assessment methodology should mention S×E×C approach');
                }
                
                if (!methodology.includes('ISO 26262')) {
                    this.addWarning(lineIndex, 'Risk assessment methodology should reference ISO 26262');
                }
            } else {
                this.addError(lineIndex, 'Methodology must be a quoted string');
            }
        }
    }

    private async validateHazardReferences(document: vscode.TextDocument, lineIndex: number, line: string): Promise<void> {
        const trimmedLine = line.trim();

        // Validate hazard references in assessments
        if (trimmedLine.startsWith('hazard ')) {
            const hazardMatch = trimmedLine.match(/hazard\s+([A-Z][A-Z0-9_]*)/);
            if (hazardMatch) {
                const hazardId = hazardMatch[1];
                
                // Check if hazard exists in hazard identification files
                const context = await this.initializeValidationContext();
                if (!context.hazards.has(hazardId)) {
                    this.addError(lineIndex, `Hazard '${hazardId}' not found in hazard identification files. Available hazards: ${Array.from(context.hazards).join(', ')}`);
                }
                
                // Validate hazard naming convention
                if (!hazardId.match(/^H_[A-Z]{3}_\d{3}$/)) {
                    this.addWarning(lineIndex, `Hazard ID '${hazardId}' should follow pattern H_XXX_NNN (e.g., H_PWR_001)`);
                }
            }
        }
    }

    private async validateOverallStructure(document: vscode.TextDocument): Promise<void> {
        const text = document.getText();
        
        // Validate that there's exactly one riskassessment definition
        const riskAssessmentMatches = text.match(/def\s+riskassessment/g);
        if (!riskAssessmentMatches) {
            this.addError(0, 'Missing "def riskassessment" definition');
        } else if (riskAssessmentMatches.length > 1) {
            this.addError(0, 'Multiple "def riskassessment" definitions found. Only one is allowed per file.');
        }

        // Validate required risk criteria sections
        this.validateRequiredRiskCriteriaSections(document);

        // Validate that each hazard assessment is complete
        await this.validateAssessmentCompleteness(document);

        // Validate cross-references to other safety files
        await this.validateSafetyFileReferences(document);

        // Validate ASIL matrix section exists if there are assessments
        this.validateASILMatrixSection(document);
    }

    private validateRequiredRiskCriteriaSections(document: vscode.TextDocument): void {
        const text = document.getText();
        const requiredCriteriaSections = ['severity', 'exposure', 'controllability'];
        
        for (const section of requiredCriteriaSections) {
            if (!text.includes(section)) {
                this.addError(0, `Missing required risk criteria section: ${section}`);
            }
        }
        
        // Validate all severity levels are defined
        const severityLevels = ['S1', 'S2', 'S3'];
        for (const level of severityLevels) {
            if (!text.includes(level)) {
                this.addWarning(0, `Missing severity level definition: ${level}`);
            }
        }
        
        // Validate all exposure levels are defined
        const exposureLevels = ['E1', 'E2', 'E3', 'E4'];
        for (const level of exposureLevels) {
            if (!text.includes(level)) {
                this.addWarning(0, `Missing exposure level definition: ${level}`);
            }
        }
        
        // Validate all controllability levels are defined
        const controllabilityLevels = ['C1', 'C2', 'C3'];
        for (const level of controllabilityLevels) {
            if (!text.includes(level)) {
                this.addWarning(0, `Missing controllability level definition: ${level}`);
            }
        }
    }

    private async validateAssessmentCompleteness(document: vscode.TextDocument): Promise<void> {
        const text = document.getText();
        const hazardMatches = text.matchAll(/hazard\s+([A-Z][A-Z0-9_]*)/g);
        
        for (const match of hazardMatches) {
            const hazardId = match[1];
            const hazardIndex = match.index!;
            
            // Find the assessment block for this hazard
            const lines = text.split('\n');
            const startLineIndex = text.substring(0, hazardIndex).split('\n').length - 1;
            
            let endLineIndex = lines.length;
            for (let i = startLineIndex + 1; i < lines.length; i++) {
                if (lines[i].trim().startsWith('hazard ')) {
                    endLineIndex = i;
                    break;
                }
            }
            
            const assessmentSection = lines.slice(startLineIndex, endLineIndex).join('\n');
            
            // Check for required assessment properties
            const requiredProperties = ['severity', 'exposure', 'controllability', 'asil', 'rationale'];
            for (const property of requiredProperties) {
                if (!assessmentSection.includes(`${property} `)) {
                    this.addError(startLineIndex, `Risk assessment for hazard '${hazardId}' is missing required property: ${property}`);
                }
            }
            
            // Check for scenario reference
            if (!assessmentSection.includes('scenario ')) {
                this.addWarning(startLineIndex, `Risk assessment for hazard '${hazardId}' should include scenario reference`);
            }
        }
    }

    private async validateSafetyFileReferences(document: vscode.TextDocument): Promise<void> {
        const text = document.getText();
        
        // Validate hazard analysis reference
        const hazardAnalysisMatch = text.match(/hazardanalysis\s+([A-Za-z][A-Za-z0-9_]*)/);
        if (hazardAnalysisMatch) {
            const hazardAnalysisRef = hazardAnalysisMatch[1];
            const context = await this.initializeValidationContext();
            if (!context.safetyFiles.has(hazardAnalysisRef)) {
                this.addError(0, `Referenced hazard analysis '${hazardAnalysisRef}' not found in workspace`);
            }
        }
        
        // Validate hazard identification reference
        const hazardIdMatch = text.match(/hazardidentification\s+([A-Za-z][A-Za-z0-9_]*)/);
        if (hazardIdMatch) {
            const hazardIdRef = hazardIdMatch[1];
            const context = await this.initializeValidationContext();
            if (!context.safetyFiles.has(hazardIdRef)) {
                this.addError(0, `Referenced hazard identification '${hazardIdRef}' not found in workspace`);
            }
        }
    }

    private validateASILMatrixSection(document: vscode.TextDocument): void {
        const text = document.getText();
        
        // If there are assessments, there should be an ASIL matrix reference
        const hasAssessments = text.includes('assessment');
        const hasASILMatrix = text.includes('asilmatrix');
        
        if (hasAssessments && !hasASILMatrix) {
            this.addInfo(0, 'Consider adding asilmatrix section to document the S×E×C to ASIL mapping table');
        }
    }
} 