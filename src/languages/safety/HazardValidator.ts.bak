import * as vscode from 'vscode';
import { BaseSafetyValidator } from './BaseSafetyValidator';
import { LanguageConfig } from '../../config/LanguageConfigs';

export class HazardValidator extends BaseSafetyValidator {
    
    constructor() {
        // Create a basic language config for safety files
        const safetyConfig: LanguageConfig = {
            id: 'sylang-safety',
            keywords: ['def', 'hazardidentification', 'hazard', 'category', 'name', 'description', 'tags', 'safetylevel'],
            requiredProperties: ['name', 'description', 'safetylevel'],
            validPropertyValues: {
                safetylevel: ['ASIL-A', 'ASIL-B', 'ASIL-C', 'ASIL-D', 'QM']
            }
        };
        super(safetyConfig);
    }

    protected getDefinitionKeywords(): string[] {
        return ['hazardidentification', 'hazard', 'category'];
    }

    protected async validateDocumentLevelRules(document: vscode.TextDocument): Promise<void> {
        await this.validateHazardIdentificationStructure(document);
        await this.validateHazardCategories(document);
        await this.validateHazardReferences(document);
    }

    protected async validateLanguageSpecificRules(document: vscode.TextDocument, lineIndex: number, line: string): Promise<void> {
        const trimmedLine = line.trim();

        // Validate hazard definitions
        if (trimmedLine.startsWith('def hazard ')) {
            this.validateHazardDefinition(document, lineIndex, line);
        }

        // Validate category definitions
        if (trimmedLine.startsWith('def category ')) {
            this.validateCategoryDefinition(document, lineIndex, line);
        }

        // Validate hazard properties
        this.validateHazardProperties(document, lineIndex, line);
    }

    public override async validate(document: vscode.TextDocument): Promise<vscode.Diagnostic[]> {
        this.diagnostics = [];
        const text = document.getText();
        const lines = text.split('\n');

        // Validate file must start with 'def hazardidentification'
        if (!text.trim().startsWith('def hazardidentification')) {
            this.addError(0, 'Hazard files (.haz) must start with "def hazardidentification <identifier>"');
        }

        // Validate required sections for .haz files
        this.validateRequiredSections(document, [
            'hazardcategories',
            'subsystemhazards'
        ]);

        // Validate line-by-line content
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (!line || line.trim().length === 0 || line.trim().startsWith('//')) {
                continue;
            }

            await this.validateLine(document, i, line);
        }

        // Validate overall structure and consistency
        await this.validateOverallStructure(document);

        return this.diagnostics;
    }

    private async validateLine(document: vscode.TextDocument, lineIndex: number, line: string): Promise<void> {
        const trimmedLine = line.trim();

        // Common validations from base class - handled by parent
        await this.validateCrossFileReferences(document, lineIndex, line);
        this.validateASILConsistency(document, lineIndex, line);
        this.validateSafetyNamingConventions(document, lineIndex, line);

        // Specific validations for .haz files
        this.validateHazardCategories(document, lineIndex, line);
        this.validateHazardDefinitions(document, lineIndex, line);
        this.validateMethodology(document, lineIndex, line);
        await this.validateSubsystemReferences(document, lineIndex, line);
    }

    private validateHazardCategories(document: vscode.TextDocument, lineIndex: number, line: string): void {
        const trimmedLine = line.trim();

        // Validate hazard category definitions
        if (trimmedLine.startsWith('category ')) {
            const categoryMatch = trimmedLine.match(/category\s+([A-Za-z][A-Za-z0-9_]*)/);
            if (categoryMatch) {
                const category = categoryMatch[1];
                
                // Validate against standard ISO 26262 hazard categories
                const standardCategories = [
                    'UnintendedActivation',
                    'FailureToActivate', 
                    'FailureToRelease',
                    'PartialFailure',
                    'DelayedResponse',
                    'MisleadingIndication'
                ];
                
                if (!standardCategories.includes(category)) {
                    this.addWarning(lineIndex, `Category '${category}' is not a standard ISO 26262 category. Standard categories: ${standardCategories.join(', ')}`);
                }
            }
        }

        // Validate severity specifications
        if (trimmedLine.startsWith('severity ')) {
            const severityValue = trimmedLine.replace('severity ', '').trim();
            if (!severityValue.startsWith('"') || !severityValue.endsWith('"')) {
                this.addError(lineIndex, 'Severity descriptions must be quoted strings');
            }
        }
    }

    private validateHazardDefinitions(document: vscode.TextDocument, lineIndex: number, line: string): void {
        const trimmedLine = line.trim();

        // Validate hazard definitions
        if (trimmedLine.startsWith('def hazard ')) {
            const hazardMatch = trimmedLine.match(/def\s+hazard\s+([A-Z][A-Z0-9_]*)/);
            if (hazardMatch) {
                const hazardId = hazardMatch[1];
                
                // Validate naming convention: H_SUBSYSTEM_NNN
                if (!hazardId.match(/^H_[A-Z]{3}_\d{3}$/)) {
                    this.addError(lineIndex, `Hazard ID '${hazardId}' must follow pattern H_XXX_NNN (e.g., H_PWR_001)`);
                }
                
                // Check for duplicate hazard IDs in the document
                const text = document.getText();
                const hazardMatches = (text.match(new RegExp(`def\\s+hazard\\s+${hazardId}`, 'g')) || []);
                if (hazardMatches.length > 1) {
                    this.addError(lineIndex, `Duplicate hazard ID '${hazardId}' found in this file`);
                }
            }
        }

        // Validate required hazard properties
        if (trimmedLine.startsWith('name ') && this.isWithinHazardDefinition(document, lineIndex)) {
            const nameValue = trimmedLine.replace('name ', '').trim();
            if (!nameValue.startsWith('"') || !nameValue.endsWith('"')) {
                this.addError(lineIndex, 'Hazard names must be quoted strings');
            }
        }

        if (trimmedLine.startsWith('cause ')) {
            const causeValue = trimmedLine.replace('cause ', '').trim();
            if (!causeValue.startsWith('"') || !causeValue.endsWith('"')) {
                this.addError(lineIndex, 'Hazard causes must be quoted strings');
            }
        }

        if (trimmedLine.startsWith('effect ')) {
            const effectValue = trimmedLine.replace('effect ', '').trim();
            if (!effectValue.startsWith('"') || !effectValue.endsWith('"')) {
                this.addError(lineIndex, 'Hazard effects must be quoted strings');
            }
        }

        if (trimmedLine.startsWith('functions_affected ')) {
            const functionsValue = trimmedLine.replace('functions_affected ', '').trim();
            if (!functionsValue.startsWith('"')) {
                this.addError(lineIndex, 'Functions affected must be quoted strings with comma-separated function names');
            }
        }
    }

    private validateMethodology(document: vscode.TextDocument, lineIndex: number, line: string): void {
        const trimmedLine = line.trim();

        // Validate methodology specification
        if (trimmedLine.startsWith('methodology ')) {
            const methodologyMatch = trimmedLine.match(/methodology\s+"([^"]+)"/);
            if (methodologyMatch) {
                const methodology = methodologyMatch[1];
                const validMethodologies = ['FMEA', 'HAZOP', 'STPA', 'FTA', 'ETA'];
                
                if (!validMethodologies.some(valid => methodology.includes(valid))) {
                    this.addWarning(lineIndex, `Methodology should include standard methods: ${validMethodologies.join(', ')}`);
                }
            } else {
                this.addError(lineIndex, 'Methodology must be a quoted string');
            }
        }
    }

    private async validateSubsystemReferences(document: vscode.TextDocument, lineIndex: number, line: string): Promise<void> {
        const trimmedLine = line.trim();

        // Validate subsystem references
        if (trimmedLine.startsWith('subsystem ')) {
            const subsystemMatch = trimmedLine.match(/subsystem\s+([A-Za-z][A-Za-z0-9_]*)/);
            if (subsystemMatch) {
                const subsystemName = subsystemMatch[1];
                
                // Check if subsystem is defined in component files
                const componentFiles = await vscode.workspace.findFiles('**/*.{cmp,sub}', '**/node_modules/**');
                let found = false;
                
                for (const fileUri of componentFiles) {
                    const doc = await vscode.workspace.openTextDocument(fileUri);
                    const content = doc.getText();
                    if (content.includes(`subsystem ${subsystemName}`) || 
                        content.includes(`component ${subsystemName}`)) {
                        found = true;
                        break;
                    }
                }
                
                if (!found) {
                    this.addWarning(lineIndex, `Subsystem '${subsystemName}' referenced but not found in component files`);
                }

                // Validate subsystem naming convention
                if (!subsystemName.match(/^[A-Z][a-zA-Z0-9]*Subsystem$/)) {
                    this.addInfo(lineIndex, `Subsystem name '${subsystemName}' should end with 'Subsystem' (e.g., ActuationControlSubsystem)`);
                }
            }
        }
    }

    private isWithinHazardDefinition(document: vscode.TextDocument, lineIndex: number): boolean {
        const lines = document.getText().split('\n');
        
        // Look backwards from current line to find the most recent 'def hazard'
        for (let i = lineIndex; i >= 0; i--) {
            const line = lines[i].trim();
            if (line.startsWith('def hazard ')) {
                return true;
            }
            if (line.startsWith('def ') && !line.startsWith('def hazard ')) {
                return false; // Found another definition, so we're not in a hazard definition
            }
        }
        return false;
    }

    private async validateOverallStructure(document: vscode.TextDocument): Promise<void> {
        const text = document.getText();
        
        // Validate that there's exactly one hazardidentification definition
        const hazardIdMatches = text.match(/def\s+hazardidentification/g);
        if (!hazardIdMatches) {
            this.addError(0, 'Missing "def hazardidentification" definition');
        } else if (hazardIdMatches.length > 1) {
            this.addError(0, 'Multiple "def hazardidentification" definitions found. Only one is allowed per file.');
        }

        // Validate that each hazard has required properties
        await this.validateHazardCompleteness(document);

        // Validate cross-references to hazard analysis file
        await this.validateHazardAnalysisReference(document);

        // Validate hazard categorization consistency
        this.validateHazardCategorizationConsistency(document);
    }

    private async validateHazardCompleteness(document: vscode.TextDocument): Promise<void> {
        const text = document.getText();
        const hazardMatches = text.matchAll(/def\s+hazard\s+([A-Z][A-Z0-9_]*)/g);
        
        for (const match of hazardMatches) {
            const hazardId = match[1];
            const hazardIndex = match.index!;
            
            // Find the end of this hazard definition
            const lines = text.split('\n');
            const startLineIndex = text.substring(0, hazardIndex).split('\n').length - 1;
            
            let endLineIndex = lines.length;
            for (let i = startLineIndex + 1; i < lines.length; i++) {
                if (lines[i].trim().startsWith('def ')) {
                    endLineIndex = i;
                    break;
                }
            }
            
            const hazardSection = lines.slice(startLineIndex, endLineIndex).join('\n');
            
            // Check for required properties
            const requiredProperties = ['name', 'description', 'cause', 'effect', 'category'];
            for (const property of requiredProperties) {
                if (!hazardSection.includes(`${property} `)) {
                    this.addError(startLineIndex, `Hazard '${hazardId}' is missing required property: ${property}`);
                }
            }
        }
    }

    private async validateHazardAnalysisReference(document: vscode.TextDocument): Promise<void> {
        const text = document.getText();
        const hazardAnalysisMatch = text.match(/hazardanalysis\s+([A-Za-z][A-Za-z0-9_]*)/);
        
        if (hazardAnalysisMatch) {
            const hazardAnalysisRef = hazardAnalysisMatch[1];
            
            // Check if referenced hazard analysis exists
            const context = await this.initializeValidationContext();
            if (!context.safetyFiles.has(hazardAnalysisRef)) {
                this.addError(0, `Referenced hazard analysis '${hazardAnalysisRef}' not found in workspace`);
            }
        } else {
            this.addWarning(0, 'No hazard analysis reference found. Consider adding "hazardanalysis <identifier>" to link to item definition');
        }
    }

    private validateHazardCategorizationConsistency(document: vscode.TextDocument): void {
        const text = document.getText();
        
        // Extract all defined categories
        const categoryMatches = text.matchAll(/category\s+([A-Za-z][A-Za-z0-9_]*)/g);
        const definedCategories = new Set<string>();
        for (const match of categoryMatches) {
            definedCategories.add(match[1]);
        }
        
        // Extract all used categories in hazard definitions
        const usedCategoryMatches = text.matchAll(/category\s+([A-Za-z][A-Za-z0-9_]*)/g);
        const usedCategories = new Set<string>();
        for (const match of usedCategoryMatches) {
            usedCategories.add(match[1]);
        }
        
        // Check for used but undefined categories
        for (const usedCategory of usedCategories) {
            if (!definedCategories.has(usedCategory)) {
                this.addError(0, `Category '${usedCategory}' is used but not defined in hazardcategories section`);
            }
        }
        
        // Check for defined but unused categories  
        for (const definedCategory of definedCategories) {
            if (!usedCategories.has(definedCategory)) {
                this.addWarning(0, `Category '${definedCategory}' is defined but not used by any hazards`);
            }
        }
    }
} 