import * as vscode from 'vscode';
import { BaseSafetyValidator } from './BaseSafetyValidator';
import { LanguageConfig } from '../../config/LanguageConfigs';

export class SafetyGoalsValidator extends BaseSafetyValidator {
    
    constructor() {
        // Create a basic language config for safety goals files
        const goalsConfig: LanguageConfig = {
            id: 'sylang-safety',
            keywords: ['def', 'safetygoals', 'goal', 'measure', 'name', 'description', 'asil', 'enables'],
            requiredProperties: ['name', 'description', 'asil'],
            validPropertyValues: {
                asil: ['A', 'B', 'C', 'D', 'QM']
            }
        };
        super(goalsConfig);
    }

    protected getDefinitionKeywords(): string[] {
        return ['safetygoals', 'goal', 'measure'];
    }

    protected async validateDocumentLevelRules(document: vscode.TextDocument): Promise<void> {
        await this.validateSafetyGoalsStructure(document);
        await this.validateRequiredSections(document);
        await this.validateGoalCompleteness(document);
    }

    protected async validateLanguageSpecificRules(document: vscode.TextDocument, lineIndex: number, line: string): Promise<void> {
        const trimmedLine = line.trim();

        // Validate safety goal definitions
        if (trimmedLine.startsWith('def goal ')) {
            this.validateSafetyGoalDefinition(document, lineIndex, line);
        }

        // Validate safety measure definitions  
        if (trimmedLine.startsWith('def measure ')) {
            this.validateSafetyMeasureDefinition(document, lineIndex, line);
        }

        // Validate ASIL levels
        if (trimmedLine.includes('asil ')) {
            this.validateASILLevel(document, lineIndex, line);
        }

        // Validate references
        if (trimmedLine.includes('hazard ') || trimmedLine.includes('scenario ')) {
            this.validateSafetyGoalReferences(document, lineIndex, line);
        }
    }

    public override async validate(document: vscode.TextDocument): Promise<vscode.Diagnostic[]> {
        this.diagnostics = [];
        const text = document.getText();
        const lines = text.split('\n');

        // Validate file must start with 'def safetygoals'
        if (!text.trim().startsWith('def safetygoals')) {
            this.addError(0, 'Safety goals files (.sgl) must start with "def safetygoals <identifier>"');
        }

        // Validate required sections for .sgl files
        this.validateRequiredSections(document, [
            'safetygoalsdef',
            'safetygoals'
        ]);

        // Validate line-by-line content
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (!line || line.trim().length === 0 || line.trim().startsWith('//')) {
                continue;
            }

            await this.validateLine(document, i, line);
        }

        // Validate overall structure and consistency
        await this.validateOverallStructure(document);

        return this.diagnostics;
    }

    private async validateLine(document: vscode.TextDocument, lineIndex: number, line: string): Promise<void> {
        const trimmedLine = line.trim();

        // Common validations from base class - handled by parent
        await this.validateCrossFileReferences(document, lineIndex, line);
        this.validateASILConsistency(document, lineIndex, line);
        this.validateSafetyNamingConventions(document, lineIndex, line);

        // Specific validations for .sgl files
        this.validateSafetyGoalsDefinition(document, lineIndex, line);
        this.validateSafetyGoalDefinitions(document, lineIndex, line);
        this.validateSafetyMeasures(document, lineIndex, line);
        await this.validateHazardAndScenarioReferences(document, lineIndex, line);
        this.validateASILLevelAssignment(document, lineIndex, line);
    }

    private validateSafetyGoalsDefinition(document: vscode.TextDocument, lineIndex: number, line: string): void {
        const trimmedLine = line.trim();

        // Validate methodology specification
        if (trimmedLine.startsWith('methodology ')) {
            const methodologyValue = trimmedLine.replace('methodology ', '').trim();
            if (!methodologyValue.startsWith('"') || !methodologyValue.endsWith('"')) {
                this.addError(lineIndex, 'Methodology must be a quoted string');
                return;
            }
            
            const methodology = methodologyValue.slice(1, -1);
            if (!methodology.includes('HARA') && !methodology.includes('ISO 26262')) {
                this.addWarning(lineIndex, 'Methodology should reference HARA and ISO 26262');
            }
        }

        // Validate principle specification
        if (trimmedLine.startsWith('principle ')) {
            const principleValue = trimmedLine.replace('principle ', '').trim();
            if (!principleValue.startsWith('"') || !principleValue.endsWith('"')) {
                this.addError(lineIndex, 'Principle must be a quoted string');
                return;
            }
            
            const principle = principleValue.slice(1, -1);
            if (!principle.toLowerCase().includes('safety goal')) {
                this.addWarning(lineIndex, 'Principle should describe safety goal definition approach');
            }
        }

        // Validate ASIL assignment specification
        if (trimmedLine.startsWith('asilassignment ')) {
            const asilAssignmentValue = trimmedLine.replace('asilassignment ', '').trim();
            if (!asilAssignmentValue.startsWith('"') || !asilAssignmentValue.endsWith('"')) {
                this.addError(lineIndex, 'ASIL assignment must be a quoted string');
                return;
            }
            
            const asilAssignment = asilAssignmentValue.slice(1, -1);
            if (!asilAssignment.includes('risk assessment') && !asilAssignment.includes('S×E×C')) {
                this.addWarning(lineIndex, 'ASIL assignment should reference risk assessment or S×E×C methodology');
            }
        }

        // Validate verification specification
        if (trimmedLine.startsWith('verification ')) {
            const verificationValue = trimmedLine.replace('verification ', '').trim();
            if (!verificationValue.startsWith('"') || !verificationValue.endsWith('"')) {
                this.addError(lineIndex, 'Verification must be a quoted string');
                return;
            }
            
            const verification = verificationValue.slice(1, -1);
            if (!verification.toLowerCase().includes('verifiable') && !verification.toLowerCase().includes('measurable')) {
                this.addWarning(lineIndex, 'Verification should describe verifiable and measurable criteria');
            }
        }
    }

    private validateSafetyGoalDefinitions(document: vscode.TextDocument, lineIndex: number, line: string): void {
        const trimmedLine = line.trim();

        // Validate safety goal definitions
        if (trimmedLine.startsWith('def goal ')) {
            const goalMatch = trimmedLine.match(/def\s+goal\s+([A-Z][A-Z0-9_]*)/);
            if (goalMatch) {
                const goalId = goalMatch[1];
                
                // Validate naming convention: SG_SYSTEM_NNN
                if (!goalId.match(/^SG_[A-Z]{3}_\d{3}$/)) {
                    this.addError(lineIndex, `Safety goal ID '${goalId}' must follow pattern SG_XXX_NNN (e.g., SG_SYS_001)`);
                }
                
                // Check for duplicate goal IDs in the document
                const text = document.getText();
                const goalMatches = (text.match(new RegExp(`def\\s+goal\\s+${goalId}`, 'g')) || []);
                if (goalMatches.length > 1) {
                    this.addError(lineIndex, `Duplicate safety goal ID '${goalId}' found in this file`);
                }
            }
        }

        // Validate required goal properties
        if (trimmedLine.startsWith('name ') && this.isWithinGoalDefinition(document, lineIndex)) {
            const nameValue = trimmedLine.replace('name ', '').trim();
            if (!nameValue.startsWith('"') || !nameValue.endsWith('"')) {
                this.addError(lineIndex, 'Safety goal names must be quoted strings');
                return;
            }
            
            const name = nameValue.slice(1, -1);
            // Safety goal names should start with action verbs
            const actionVerbs = ['prevent', 'ensure', 'maintain', 'provide', 'avoid', 'eliminate'];
            if (!actionVerbs.some(verb => name.toLowerCase().startsWith(verb))) {
                this.addWarning(lineIndex, `Safety goal name should start with action verb: ${actionVerbs.join(', ')}`);
            }
        }

        if (trimmedLine.startsWith('description ') && this.isWithinGoalDefinition(document, lineIndex)) {
            const descriptionValue = trimmedLine.replace('description ', '').trim();
            if (!descriptionValue.startsWith('"') || !descriptionValue.endsWith('"')) {
                this.addError(lineIndex, 'Safety goal descriptions must be quoted strings');
                return;
            }
            
            const description = descriptionValue.slice(1, -1);
            if (!description.toLowerCase().includes('shall')) {
                this.addWarning(lineIndex, 'Safety goal description should include "shall" to indicate requirement');
            }
        }
    }

    private validateSafetyMeasures(document: vscode.TextDocument, lineIndex: number, line: string): void {
        const trimmedLine = line.trim();

        // Validate safety measure definitions
        if (trimmedLine.startsWith('def measure ')) {
            const measureMatch = trimmedLine.match(/def\s+measure\s+([A-Z][A-Z0-9_]*)\s+"([^"]+)"/);
            if (!measureMatch) {
                this.addError(lineIndex, 'Safety measures must follow format: def measure SM_NNN "description"');
                return;
            }
            
            const measureId = measureMatch[1];
            const description = measureMatch[2];
            
            // Validate naming convention: SM_NNN
            if (!measureId.match(/^SM_\d{3}$/)) {
                this.addWarning(lineIndex, `Safety measure ID '${measureId}' should follow pattern SM_NNN (e.g., SM_001)`);
            }
            
            // Validate description content
            if (description.length < 10) {
                this.addWarning(lineIndex, 'Safety measure description should be more detailed');
            }
            
            // Check for action-oriented descriptions
            const actionKeywords = ['monitor', 'detect', 'prevent', 'shutdown', 'validate', 'verify', 'redundant', 'backup'];
            if (!actionKeywords.some(keyword => description.toLowerCase().includes(keyword))) {
                this.addInfo(lineIndex, `Consider including action keywords in measure description: ${actionKeywords.join(', ')}`);
            }
        }

        // Validate enabledby references
        if (trimmedLine.startsWith('enabledby ') && this.isWithinMeasureDefinition(document, lineIndex)) {
            const enabledByValue = trimmedLine.replace('enabledby ', '').trim();
            const functionRefs = enabledByValue.split(',').map(ref => ref.trim());
            
            if (functionRefs.length === 0) {
                this.addError(lineIndex, 'Safety measures must be enabled by at least one function');
            }
            
            // Validate function naming conventions
            for (const funcRef of functionRefs) {
                if (!funcRef.match(/^[A-Z][a-zA-Z0-9]*$/)) {
                    this.addWarning(lineIndex, `Function reference '${funcRef}' should use PascalCase naming`);
                }
            }
        }
    }

    private async validateHazardAndScenarioReferences(document: vscode.TextDocument, lineIndex: number, line: string): Promise<void> {
        const trimmedLine = line.trim();

        // Validate hazard references
        if (trimmedLine.startsWith('hazard ')) {
            const hazardRefs = trimmedLine.replace('hazard ', '').split(',').map(ref => ref.trim());
            const context = await this.initializeValidationContext();
            
            for (const hazardRef of hazardRefs) {
                if (!context.hazards.has(hazardRef)) {
                    this.addError(lineIndex, `Hazard '${hazardRef}' not found in hazard identification files. Available hazards: ${Array.from(context.hazards).join(', ')}`);
                }
                
                // Validate hazard naming convention
                if (!hazardRef.match(/^H_[A-Z]{3}_\d{3}$/)) {
                    this.addWarning(lineIndex, `Hazard ID '${hazardRef}' should follow pattern H_XXX_NNN (e.g., H_PWR_001)`);
                }
            }
        }

        // Validate scenario references
        if (trimmedLine.startsWith('scenario ')) {
            const scenarioRefs = trimmedLine.replace('scenario ', '').split(',').map(ref => ref.trim());
            const context = await this.initializeValidationContext();
            
            for (const scenarioRef of scenarioRefs) {
                if (!context.scenarios.has(scenarioRef)) {
                    this.addError(lineIndex, `Scenario '${scenarioRef}' not found in hazard analysis files. Available scenarios: ${Array.from(context.scenarios).join(', ')}`);
                }
                
                // Validate scenario naming convention
                if (!scenarioRef.match(/^SCEN_\d{3}_[A-Za-z][A-Za-z0-9_]*$/)) {
                    this.addWarning(lineIndex, `Scenario ID '${scenarioRef}' should follow pattern SCEN_NNN_Name (e.g., SCEN_001_NormalDriving)`);
                }
            }
        }
    }

    private validateASILLevelAssignment(document: vscode.TextDocument, lineIndex: number, line: string): void {
        const trimmedLine = line.trim();

        // Validate ASIL level assignment within goals
        if (trimmedLine.startsWith('asil ') && this.isWithinGoalDefinition(document, lineIndex)) {
            const asilMatch = trimmedLine.match(/asil\s+([A-D]|QM)/);
            if (!asilMatch) {
                this.addError(lineIndex, 'Invalid ASIL level. Valid values are: A, B, C, D, QM');
                return;
            }
            
            const asilLevel = asilMatch[1];
            
            // Validate ASIL level consistency with referenced hazards
            this.validateASILConsistencyWithHazards(document, lineIndex, asilLevel);
        }
    }

    private async validateASILConsistencyWithHazards(document: vscode.TextDocument, goalLineIndex: number, goalASIL: string): Promise<void> {
        const lines = document.getText().split('\n');
        
        // Find the current goal block
        let goalStart = goalLineIndex;
        let goalEnd = goalLineIndex;
        
        // Find goal start
        for (let i = goalLineIndex; i >= 0; i--) {
            if (lines[i].trim().startsWith('def goal ')) {
                goalStart = i;
                break;
            }
        }
        
        // Find goal end
        for (let i = goalLineIndex; i < lines.length; i++) {
            if (lines[i].trim().startsWith('def goal ') && i > goalLineIndex) {
                goalEnd = i;
                break;
            }
            if (i === lines.length - 1) {
                goalEnd = i;
                break;
            }
        }
        
        // Extract hazard references from the goal block
        const goalBlock = lines.slice(goalStart, goalEnd).join('\n');
        const hazardMatches = goalBlock.matchAll(/hazard\s+([A-Z][A-Z0-9_,\s]*)/g);
        
        for (const match of hazardMatches) {
            const hazardRefs = match[1].split(',').map(ref => ref.trim());
            
            // For each referenced hazard, check its ASIL level in risk assessment files
            for (const hazardRef of hazardRefs) {
                await this.validateHazardASILConsistency(goalASIL, hazardRef, goalLineIndex);
            }
        }
    }

    private async validateHazardASILConsistency(goalASIL: string, hazardRef: string, lineIndex: number): Promise<void> {
        // Find risk assessment files that contain this hazard
        const riskFiles = await vscode.workspace.findFiles('**/*.rsk', '**/node_modules/**');
        
        for (const fileUri of riskFiles) {
            const doc = await vscode.workspace.openTextDocument(fileUri);
            const content = doc.getText();
            
            if (content.includes(`hazard ${hazardRef}`)) {
                // Extract ASIL level for this hazard from risk assessment
                const hazardBlockMatch = content.match(new RegExp(`hazard\\s+${hazardRef}[\\s\\S]*?asil\\s+([A-D]|QM)`, 'i'));
                if (hazardBlockMatch) {
                    const hazardASIL = hazardBlockMatch[1];
                    
                    // ASIL levels have hierarchy: D > C > B > A > QM
                    const asilHierarchy = { 'QM': 0, 'A': 1, 'B': 2, 'C': 3, 'D': 4 };
                    const goalLevel = asilHierarchy[goalASIL as keyof typeof asilHierarchy] || 0;
                    const hazardLevel = asilHierarchy[hazardASIL as keyof typeof asilHierarchy] || 0;
                    
                    if (goalLevel < hazardLevel) {
                        this.addError(lineIndex, `Safety goal ASIL ${goalASIL} is lower than hazard ${hazardRef} ASIL ${hazardASIL}. Goal ASIL should be ≥ highest referenced hazard ASIL`);
                    }
                }
                break;
            }
        }
    }

    private isWithinGoalDefinition(document: vscode.TextDocument, lineIndex: number): boolean {
        const lines = document.getText().split('\n');
        
        // Look backwards from current line to find the most recent 'def goal'
        for (let i = lineIndex; i >= 0; i--) {
            const line = lines[i].trim();
            if (line.startsWith('def goal ')) {
                return true;
            }
            if (line.startsWith('def ') && !line.startsWith('def goal ')) {
                return false; // Found another definition
            }
        }
        return false;
    }

    private isWithinMeasureDefinition(document: vscode.TextDocument, lineIndex: number): boolean {
        const lines = document.getText().split('\n');
        
        // Look backwards from current line to find the most recent 'def measure'
        for (let i = lineIndex; i >= 0; i--) {
            const line = lines[i].trim();
            if (line.startsWith('def measure ')) {
                return true;
            }
            if (line.startsWith('def ') && !line.startsWith('def measure ')) {
                return false; // Found another definition
            }
        }
        return false;
    }

    private async validateOverallStructure(document: vscode.TextDocument): Promise<void> {
        const text = document.getText();
        
        // Validate that there's exactly one safetygoals definition
        const safetyGoalsMatches = text.match(/def\s+safetygoals/g);
        if (!safetyGoalsMatches) {
            this.addError(0, 'Missing "def safetygoals" definition');
        } else if (safetyGoalsMatches.length > 1) {
            this.addError(0, 'Multiple "def safetygoals" definitions found. Only one is allowed per file.');
        }

        // Validate that each safety goal has required properties
        await this.validateGoalCompleteness(document);

        // Validate cross-references to other safety files
        await this.validateSafetyFileReferences(document);

        // Validate section order
        this.validateSectionOrder(document);

        // Validate ASIL coverage
        this.validateASILCoverage(document);
    }

    private async validateGoalCompleteness(document: vscode.TextDocument): Promise<void> {
        const text = document.getText();
        const goalMatches = text.matchAll(/def\s+goal\s+([A-Z][A-Z0-9_]*)/g);
        
        for (const match of goalMatches) {
            const goalId = match[1];
            const goalIndex = match.index!;
            
            // Find the end of this goal definition
            const lines = text.split('\n');
            const startLineIndex = text.substring(0, goalIndex).split('\n').length - 1;
            
            let endLineIndex = lines.length;
            for (let i = startLineIndex + 1; i < lines.length; i++) {
                if (lines[i].trim().startsWith('def goal ')) {
                    endLineIndex = i;
                    break;
                }
            }
            
            const goalSection = lines.slice(startLineIndex, endLineIndex).join('\n');
            
            // Check for required properties
            const requiredProperties = ['name', 'description', 'hazard', 'asil', 'safetymeasures'];
            for (const property of requiredProperties) {
                if (!goalSection.includes(`${property} `)) {
                    this.addError(startLineIndex, `Safety goal '${goalId}' is missing required property: ${property}`);
                }
            }
            
            // Check for at least one safety measure
            if (!goalSection.includes('def measure ')) {
                this.addError(startLineIndex, `Safety goal '${goalId}' must have at least one safety measure`);
            }
        }
    }

    private async validateSafetyFileReferences(document: vscode.TextDocument): Promise<void> {
        const text = document.getText();
        const context = await this.initializeValidationContext();
        
        // Validate hazard analysis reference
        const hazardAnalysisMatch = text.match(/hazardanalysis\s+([A-Za-z][A-Za-z0-9_]*)/);
        if (hazardAnalysisMatch) {
            const hazardAnalysisRef = hazardAnalysisMatch[1];
            if (!context.safetyFiles.has(hazardAnalysisRef)) {
                this.addError(0, `Referenced hazard analysis '${hazardAnalysisRef}' not found in workspace`);
            }
        }
        
        // Validate risk assessment reference
        const riskAssessmentMatch = text.match(/riskassessment\s+([A-Za-z][A-Za-z0-9_]*)/);
        if (riskAssessmentMatch) {
            const riskAssessmentRef = riskAssessmentMatch[1];
            if (!context.safetyFiles.has(riskAssessmentRef)) {
                this.addError(0, `Referenced risk assessment '${riskAssessmentRef}' not found in workspace`);
            }
        }
        
        // Validate hazard identification reference
        const hazardIdMatch = text.match(/hazardidentification\s+([A-Za-z][A-Za-z0-9_]*)/);
        if (hazardIdMatch) {
            const hazardIdRef = hazardIdMatch[1];
            if (!context.safetyFiles.has(hazardIdRef)) {
                this.addError(0, `Referenced hazard identification '${hazardIdRef}' not found in workspace`);
            }
        }
    }

    private validateSectionOrder(document: vscode.TextDocument): void {
        const text = document.getText();
        
        // Validate section order: safetygoalsdef → safetygoals
        const sectionOrder = ['safetygoalsdef', 'safetygoals'];
        let lastFoundIndex = -1;
        
        for (const section of sectionOrder) {
            const sectionIndex = text.indexOf(section);
            if (sectionIndex !== -1) {
                if (sectionIndex < lastFoundIndex) {
                    this.addWarning(0, `Section '${section}' appears before previous required section. Recommended order: ${sectionOrder.join(' → ')}`);
                }
                lastFoundIndex = sectionIndex;
            }
        }
    }

    private validateASILCoverage(document: vscode.TextDocument): void {
        const text = document.getText();
        
        // Extract all ASIL levels from safety goals
        const asilMatches = text.matchAll(/asil\s+([A-D]|QM)/g);
        const asilLevels = new Set<string>();
        
        for (const match of asilMatches) {
            asilLevels.add(match[1]);
        }
        
        // Check if high ASIL levels (C, D) have sufficient coverage
        if (asilLevels.has('D')) {
            const dGoals = (text.match(/asil\s+D/g) || []).length;
            if (dGoals < 2) {
                this.addInfo(0, 'ASIL D systems typically require multiple safety goals for comprehensive coverage');
            }
        }
        
        if (asilLevels.has('C')) {
            const cGoals = (text.match(/asil\s+C/g) || []).length;
            if (cGoals < 2) {
                this.addInfo(0, 'ASIL C systems typically require multiple safety goals for comprehensive coverage');
            }
        }
    }
} 