import * as vscode from 'vscode';
import { BaseValidator } from '../base/BaseValidator';
import { ProjectAnalyzer } from '../../core/ProjectAnalyzer';
import { SymbolManager } from '../../core/SymbolManager';
import { LanguageConfig } from '../../config/LanguageConfigs';

export interface SafetyValidationContext {
    productLines: Map<string, string>; // identifier -> file path
    features: Map<string, string>; // identifier -> file path
    functions: Map<string, string>; // identifier -> file path
    safetyFiles: Map<string, string>; // identifier -> file path
    hazards: Set<string>; // hazard identifiers
    scenarios: Set<string>; // scenario identifiers
    safetyGoals: Set<string>; // safety goal identifiers
    requirements: Set<string>; // requirement identifiers
}

export abstract class BaseSafetyValidator extends BaseValidator {
    protected projectAnalyzer: ProjectAnalyzer;
    protected symbolManager: SymbolManager;
    protected validationContext: SafetyValidationContext | null = null;

    constructor(languageConfig: LanguageConfig) {
        super(languageConfig);
        this.projectAnalyzer = new ProjectAnalyzer('');
        this.symbolManager = new SymbolManager();
    }

    // Convenience methods for error reporting
    protected addError(lineIndex: number, message: string): void {
        const range = new vscode.Range(lineIndex, 0, lineIndex, Number.MAX_VALUE);
        const diagnostic = new vscode.Diagnostic(
            range,
            message,
            vscode.DiagnosticSeverity.Error
        );
        this.diagnostics.push(diagnostic);
    }

    protected addWarning(lineIndex: number, message: string): void {
        const range = new vscode.Range(lineIndex, 0, lineIndex, Number.MAX_VALUE);
        const diagnostic = new vscode.Diagnostic(
            range,
            message,
            vscode.DiagnosticSeverity.Warning
        );
        this.diagnostics.push(diagnostic);
    }

    protected addInfo(lineIndex: number, message: string): void {
        const range = new vscode.Range(lineIndex, 0, lineIndex, Number.MAX_VALUE);
        const diagnostic = new vscode.Diagnostic(
            range,
            message,
            vscode.DiagnosticSeverity.Information
        );
        this.diagnostics.push(diagnostic);
    }

    // Default implementations that child classes can override
    protected getDefinitionKeywords(): string[] {
        return ['def'];
    }

    protected async validateDocumentLevelRules(document: vscode.TextDocument): Promise<void> {
        // Default implementation - can be overridden by child classes
    }

    protected async validateLanguageSpecificRules(document: vscode.TextDocument, lineIndex: number, line: string): Promise<void> {
        // Default implementation - can be overridden by child classes
    }

    /**
     * Initialize validation context by scanning workspace for all relevant symbols
     */
    protected async initializeValidationContext(): Promise<SafetyValidationContext> {
        if (this.validationContext) {
            return this.validationContext;
        }

        const context: SafetyValidationContext = {
            productLines: new Map(),
            features: new Map(),
            functions: new Map(),
            safetyFiles: new Map(),
            hazards: new Set(),
            scenarios: new Set(),
            safetyGoals: new Set(),
            requirements: new Set()
        };

        try {
            // Find all Sylang files in workspace
            const sylangFiles = await vscode.workspace.findFiles('**/*.{ple,fml,fun,itm,haz,rsk,sgl,fsr}', '**/node_modules/**');
            
            for (const fileUri of sylangFiles) {
                const document = await vscode.workspace.openTextDocument(fileUri);
                const text = document.getText();
                const extension = fileUri.path.split('.').pop();
                
                // Extract symbols based on file type
                switch (extension) {
                    case 'ple':
                        this.extractProductLineSymbols(text, fileUri.fsPath, context);
                        break;
                    case 'fml':
                        this.extractFeatureSymbols(text, fileUri.fsPath, context);
                        break;
                    case 'fun':
                        this.extractFunctionSymbols(text, fileUri.fsPath, context);
                        break;
                    case 'itm':
                        this.extractHazardAnalysisSymbols(text, fileUri.fsPath, context);
                        break;
                    case 'haz':
                        this.extractHazardSymbols(text, fileUri.fsPath, context);
                        break;
                    case 'rsk':
                        this.extractRiskSymbols(text, fileUri.fsPath, context);
                        break;
                    case 'sgl':
                        this.extractSafetyGoalSymbols(text, fileUri.fsPath, context);
                        break;
                    case 'fsr':
                        this.extractRequirementSymbols(text, fileUri.fsPath, context);
                        break;
                }
            }
        } catch (error) {
            console.error('[BaseSafetyValidator] Error initializing validation context:', error);
        }

        this.validationContext = context;
        return context;
    }

    /**
     * Extract product line identifiers from .ple files
     */
    private extractProductLineSymbols(text: string, filePath: string, context: SafetyValidationContext): void {
        const productLineMatch = text.match(/def\s+productline\s+([A-Za-z][A-Za-z0-9_]*)/);
        if (productLineMatch) {
            context.productLines.set(productLineMatch[1], filePath);
        }
    }

    /**
     * Extract feature identifiers from .fml files
     */
    private extractFeatureSymbols(text: string, filePath: string, context: SafetyValidationContext): void {
        const systemFeaturesMatch = text.match(/def\s+systemfeatures\s+([A-Za-z][A-Za-z0-9_]*)/);
        if (systemFeaturesMatch) {
            context.features.set(systemFeaturesMatch[1], filePath);
        }

        // Extract individual feature identifiers
        const featureMatches = text.matchAll(/def\s+feature\s+([A-Za-z][A-Za-z0-9_]*)/g);
        for (const match of featureMatches) {
            context.features.set(match[1], filePath);
        }
    }

    /**
     * Extract function identifiers from .fun files
     */
    private extractFunctionSymbols(text: string, filePath: string, context: SafetyValidationContext): void {
        const systemFunctionsMatch = text.match(/def\s+systemfunctions\s+([A-Za-z][A-Za-z0-9_]*)/);
        if (systemFunctionsMatch) {
            context.functions.set(systemFunctionsMatch[1], filePath);
        }

        // Extract individual function identifiers
        const functionMatches = text.matchAll(/def\s+function\s+([A-Za-z][A-Za-z0-9_]*)/g);
        for (const match of functionMatches) {
            context.functions.set(match[1], filePath);
        }
    }

    /**
     * Extract hazard analysis symbols from .itm files
     */
    private extractHazardAnalysisSymbols(text: string, filePath: string, context: SafetyValidationContext): void {
        const hazardAnalysisMatch = text.match(/def\s+hazardanalysis\s+([A-Za-z][A-Za-z0-9_]*)/);
        if (hazardAnalysisMatch) {
            context.safetyFiles.set(hazardAnalysisMatch[1], filePath);
        }

        // Extract scenario identifiers
        const scenarioMatches = text.matchAll(/def\s+scenario\s+([A-Za-z][A-Za-z0-9_]*)/g);
        for (const match of scenarioMatches) {
            context.scenarios.add(match[1]);
        }
    }

    /**
     * Extract hazard identifiers from .haz files
     */
    private extractHazardSymbols(text: string, filePath: string, context: SafetyValidationContext): void {
        const hazardIdentificationMatch = text.match(/def\s+hazardidentification\s+([A-Za-z][A-Za-z0-9_]*)/);
        if (hazardIdentificationMatch) {
            context.safetyFiles.set(hazardIdentificationMatch[1], filePath);
        }

        // Extract hazard identifiers
        const hazardMatches = text.matchAll(/def\s+hazard\s+([A-Z][A-Z0-9_]*)/g);
        for (const match of hazardMatches) {
            context.hazards.add(match[1]);
        }
    }

    /**
     * Extract risk assessment symbols from .rsk files
     */
    private extractRiskSymbols(text: string, filePath: string, context: SafetyValidationContext): void {
        const riskAssessmentMatch = text.match(/def\s+riskassessment\s+([A-Za-z][A-Za-z0-9_]*)/);
        if (riskAssessmentMatch) {
            context.safetyFiles.set(riskAssessmentMatch[1], filePath);
        }
    }

    /**
     * Extract safety goal symbols from .sgl files
     */
    private extractSafetyGoalSymbols(text: string, filePath: string, context: SafetyValidationContext): void {
        const safetyGoalsMatch = text.match(/def\s+safetygoals\s+([A-Za-z][A-Za-z0-9_]*)/);
        if (safetyGoalsMatch) {
            context.safetyFiles.set(safetyGoalsMatch[1], filePath);
        }

        // Extract safety goal identifiers
        const goalMatches = text.matchAll(/def\s+goal\s+([A-Z][A-Z0-9_]*)/g);
        for (const match of goalMatches) {
            context.safetyGoals.add(match[1]);
        }
    }

    /**
     * Extract requirement symbols from .fsr files
     */
    private extractRequirementSymbols(text: string, filePath: string, context: SafetyValidationContext): void {
        const requirementsMatch = text.match(/def\s+functionalsafetyrequirements\s+([A-Za-z][A-Za-z0-9_]*)/);
        if (requirementsMatch) {
            context.safetyFiles.set(requirementsMatch[1], filePath);
        }

        // Extract requirement identifiers
        const requirementMatches = text.matchAll(/def\s+requirement\s+([A-Z][A-Z0-9_]*)/g);
        for (const match of requirementMatches) {
            context.requirements.add(match[1]);
        }
    }

    /**
     * Validate cross-file references for safety files
     */
    protected async validateCrossFileReferences(document: vscode.TextDocument, lineIndex: number, line: string): Promise<void> {
        const context = await this.initializeValidationContext();
        const trimmedLine = line.trim();

        // Validate product line references
        if (trimmedLine.startsWith('productline ')) {
            const productLineRef = this.extractIdentifier(trimmedLine, 'productline');
            if (productLineRef && !context.productLines.has(productLineRef)) {
                this.addError(lineIndex, `Product line '${productLineRef}' not found. Available: ${Array.from(context.productLines.keys()).join(', ')}`);
            }
        }

        // Validate system features references
        if (trimmedLine.startsWith('systemfeatures ')) {
            const featuresRef = this.extractIdentifier(trimmedLine, 'systemfeatures');
            if (featuresRef && !context.features.has(featuresRef)) {
                this.addError(lineIndex, `System features '${featuresRef}' not found. Available: ${Array.from(context.features.keys()).join(', ')}`);
            }
        }

        // Validate system functions references
        if (trimmedLine.startsWith('systemfunctions ')) {
            const functionsRef = this.extractIdentifier(trimmedLine, 'systemfunctions');
            if (functionsRef && !context.functions.has(functionsRef)) {
                this.addError(lineIndex, `System functions '${functionsRef}' not found. Available: ${Array.from(context.functions.keys()).join(', ')}`);
            }
        }

        // Validate enabledby references (functions)
        if (trimmedLine.startsWith('enabledby ')) {
            const enabledByRefs = this.extractCommaSeparatedIdentifiers(trimmedLine, 'enabledby');
            for (const funcRef of enabledByRefs) {
                if (!context.functions.has(funcRef)) {
                    this.addError(lineIndex, `Function '${funcRef}' referenced in enabledby not found. Available functions: ${Array.from(context.functions.keys()).join(', ')}`);
                }
            }
        }

        // Validate hazard references
        if (trimmedLine.startsWith('hazard ')) {
            const hazardRefs = this.extractCommaSeparatedIdentifiers(trimmedLine, 'hazard');
            for (const hazardRef of hazardRefs) {
                if (!context.hazards.has(hazardRef)) {
                    this.addError(lineIndex, `Hazard '${hazardRef}' not found. Available hazards: ${Array.from(context.hazards).join(', ')}`);
                }
            }
        }

        // Validate scenario references
        if (trimmedLine.startsWith('scenario ')) {
            const scenarioRefs = this.extractCommaSeparatedIdentifiers(trimmedLine, 'scenario');
            for (const scenarioRef of scenarioRefs) {
                if (!context.scenarios.has(scenarioRef)) {
                    this.addError(lineIndex, `Scenario '${scenarioRef}' not found. Available scenarios: ${Array.from(context.scenarios).join(', ')}`);
                }
            }
        }

        // Validate safety goal references in derivedfrom
        if (trimmedLine.startsWith('derivedfrom ')) {
            const derivedFromRefs = this.extractCommaSeparatedIdentifiers(trimmedLine, 'derivedfrom');
            for (const goalRef of derivedFromRefs) {
                if (!context.safetyGoals.has(goalRef)) {
                    this.addError(lineIndex, `Safety goal '${goalRef}' referenced in derivedfrom not found. Available goals: ${Array.from(context.safetyGoals).join(', ')}`);
                }
            }
        }

        // Validate safety file cross-references
        const safetyFileKeywords = ['hazardanalysis', 'hazardidentification', 'riskassessment', 'safetygoals'];
        for (const keyword of safetyFileKeywords) {
            if (trimmedLine.startsWith(`${keyword} `)) {
                const safetyFileRef = this.extractIdentifier(trimmedLine, keyword);
                if (safetyFileRef && !context.safetyFiles.has(safetyFileRef)) {
                    this.addError(lineIndex, `Safety file '${safetyFileRef}' not found. Available: ${Array.from(context.safetyFiles.keys()).join(', ')}`);
                }
            }
        }
    }

    /**
     * Extract identifier after a keyword
     */
    private extractIdentifier(line: string, keyword: string): string | null {
        const regex = new RegExp(`${keyword}\\s+([A-Za-z][A-Za-z0-9_]*)`);
        const match = line.match(regex);
        return match ? match[1] : null;
    }

    /**
     * Extract comma-separated identifiers after a keyword
     */
    private extractCommaSeparatedIdentifiers(line: string, keyword: string): string[] {
        const regex = new RegExp(`${keyword}\\s+(.+)`);
        const match = line.match(regex);
        if (!match) return [];

        return match[1]
            .split(',')
            .map(id => id.trim())
            .filter(id => id.length > 0);
    }

    /**
     * Validate ASIL levels and their consistency
     */
    protected validateASILConsistency(document: vscode.TextDocument, lineIndex: number, line: string): void {
        const trimmedLine = line.trim();
        
        if (trimmedLine.startsWith('asil ')) {
            const asilMatch = trimmedLine.match(/asil\s+([A-D]|QM)/);
            if (!asilMatch) {
                this.addError(lineIndex, 'Invalid ASIL level. Valid values are: A, B, C, D, QM');
                return;
            }

            const asilLevel = asilMatch[1];
            
            // Additional ASIL validation rules based on context
            if (trimmedLine.includes('severity') || trimmedLine.includes('exposure') || trimmedLine.includes('controllability')) {
                // This might be part of S×E×C assessment - validate consistency
                this.validateSECConsistency(document, lineIndex, line, asilLevel);
            }
        }
    }

    /**
     * Validate S×E×C (Severity × Exposure × Controllability) consistency with ASIL
     */
    private validateSECConsistency(document: vscode.TextDocument, lineIndex: number, line: string, asilLevel: string): void {
        // This would implement the ISO 26262 S×E×C to ASIL mapping validation
        // For now, just validate that S, E, C values are valid
        const text = document.getText();
        const lines = text.split('\n');
        
        // Look for S, E, C values in nearby lines
        let severity: string | null = null;
        let exposure: string | null = null;
        let controllability: string | null = null;
        
        // Check lines around the current line for S×E×C values
        for (let i = Math.max(0, lineIndex - 5); i < Math.min(lines.length, lineIndex + 5); i++) {
            const nearbyLine = lines[i].trim();
            
            if (nearbyLine.match(/severity\s+(S[1-3])/)) {
                severity = RegExp.$1;
            }
            if (nearbyLine.match(/exposure\s+(E[1-4])/)) {
                exposure = RegExp.$1;
            }
            if (nearbyLine.match(/controllability\s+(C[1-3])/)) {
                controllability = RegExp.$1;
            }
        }
        
        // Validate S×E×C values are valid
        if (severity && !['S1', 'S2', 'S3'].includes(severity)) {
            this.addError(lineIndex, `Invalid severity value: ${severity}. Valid values are: S1, S2, S3`);
        }
        if (exposure && !['E1', 'E2', 'E3', 'E4'].includes(exposure)) {
            this.addError(lineIndex, `Invalid exposure value: ${exposure}. Valid values are: E1, E2, E3, E4`);
        }
        if (controllability && !['C1', 'C2', 'C3'].includes(controllability)) {
            this.addError(lineIndex, `Invalid controllability value: ${controllability}. Valid values are: C1, C2, C3`);
        }
    }

    /**
     * Validate required sections for safety files
     */
    protected validateRequiredSections(document: vscode.TextDocument, requiredSections: string[]): void {
        const text = document.getText();
        
        for (const section of requiredSections) {
            if (!text.includes(section)) {
                const range = new vscode.Range(0, 0, 0, 0);
                const diagnostic = new vscode.Diagnostic(
                    range,
                    `Missing required section: ${section}`,
                    vscode.DiagnosticSeverity.Error
                );
                diagnostic.code = 'missing-required-section';
                this.diagnostics.push(diagnostic);
            }
        }
    }

    /**
     * Validate naming conventions for safety identifiers
     */
    protected validateSafetyNamingConventions(document: vscode.TextDocument, lineIndex: number, line: string): void {
        const trimmedLine = line.trim();
        
        // Validate hazard naming convention (H_SUBSYSTEM_NNN)
        const hazardMatch = trimmedLine.match(/def\s+hazard\s+([A-Z][A-Z0-9_]*)/);
        if (hazardMatch) {
            const hazardId = hazardMatch[1];
            if (!hazardId.match(/^H_[A-Z]{3}_\d{3}$/)) {
                this.addWarning(lineIndex, `Hazard ID '${hazardId}' should follow pattern H_XXX_NNN (e.g., H_PWR_001)`);
            }
        }
        
        // Validate safety goal naming convention (SG_SYSTEM_NNN)
        const goalMatch = trimmedLine.match(/def\s+goal\s+([A-Z][A-Z0-9_]*)/);
        if (goalMatch) {
            const goalId = goalMatch[1];
            if (!goalId.match(/^SG_[A-Z]{3}_\d{3}$/)) {
                this.addWarning(lineIndex, `Safety goal ID '${goalId}' should follow pattern SG_XXX_NNN (e.g., SG_SYS_001)`);
            }
        }
        
        // Validate requirement naming convention (FSR_SYSTEM_NNN)
        const reqMatch = trimmedLine.match(/def\s+requirement\s+([A-Z][A-Z0-9_]*)/);
        if (reqMatch) {
            const reqId = reqMatch[1];
            if (!reqId.match(/^FSR_[A-Z]{3}_\d{3}$/)) {
                this.addWarning(lineIndex, `Requirement ID '${reqId}' should follow pattern FSR_XXX_NNN (e.g., FSR_SYS_001)`);
            }
        }
        
        // Validate scenario naming convention (SCEN_NNN_Name)
        const scenMatch = trimmedLine.match(/def\s+scenario\s+([A-Z][A-Za-z0-9_]*)/);
        if (scenMatch) {
            const scenId = scenMatch[1];
            if (!scenId.match(/^SCEN_\d{3}_[A-Za-z][A-Za-z0-9_]*$/)) {
                this.addWarning(lineIndex, `Scenario ID '${scenId}' should follow pattern SCEN_NNN_Name (e.g., SCEN_001_NormalDriving)`);
            }
        }
    }

    /**
     * Reset validation context (call when workspace changes)
     */
    public resetValidationContext(): void {
        this.validationContext = null;
    }
} 